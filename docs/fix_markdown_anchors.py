#!/usr/bin/env python3
"""
Post-process Sphinx-generated markdown to add HTML anchors for cross-references.

This script fixes broken cross-reference links in markdown generated by
sphinx-markdown-builder. The builder generates links with domain prefixes
(e.g., #c.JINTEGER) but doesn't create matching anchors.
"""

import re
import sys
from pathlib import Path


def extract_anchor_id(link):
    """Extract the anchor ID from a markdown link."""
    # Match [text](#anchor) format
    match = re.search(r'\[([^\]]+)\]\(#([^)]+)\)', link)
    if match:
        return match.group(2)
    return None


def find_definition_anchors(content):
    """
    Find all cross-reference links and extract their anchor IDs.
    Returns a dict mapping anchor IDs to the link text (identifier name).
    """
    anchor_map = {}

    # Find all internal anchor links (e.g., #c.JINTEGER, #note_8h_1a234...)
    # This pattern catches any internal link
    pattern = r'\[([^\]]+)\]\(#([^)]+)\)'
    matches = re.findall(pattern, content)

    for link_text, anchor_id in matches:
        # Extract identifier from link text (strip markdown formatting)
        # Remove any inline code backticks or other markdown
        identifier = re.sub(r'`', '', link_text).strip()
        # Store the anchor ID and what identifier it refers to
        anchor_map[anchor_id] = identifier

    return anchor_map


def add_anchors_to_definitions(content, anchor_map):
    """
    Add HTML anchors before function and type definitions.

    We look for headings that match the identifiers we found cross-references to,
    and add HTML anchor tags before them.

    Args:
        content: The markdown content
        anchor_map: Dict mapping anchor IDs to identifier names
    """
    lines = content.split('\n')
    output_lines = []

    # Build reverse map: identifier -> list of anchor IDs
    identifier_to_anchors = {}
    for anchor_id, identifier in anchor_map.items():
        if identifier not in identifier_to_anchors:
            identifier_to_anchors[identifier] = []
        identifier_to_anchors[identifier].append(anchor_id)

    for i, line in enumerate(lines):
        # Check if this is a heading line
        if line.startswith('### '):
            heading_text = line[4:].strip()

            # Try to extract the identifier from various heading formats
            identifier = None

            # Match type pointers FIRST: "typedef ... (*NAME)(...)"
            # Need to handle escaped asterisks in markdown: \*
            normalized = heading_text.replace('\\*', '*')
            typedef_ptr_match = re.search(r'\(\*(\w+)\)', normalized)
            if typedef_ptr_match:
                identifier = typedef_ptr_match.group(1)

            # Match typedef: "typedef ... NAME"
            if not identifier:
                typedef_match = re.match(r'^typedef\s+.*\s+(\w+)\s*$', heading_text)
                if typedef_match:
                    identifier = typedef_match.group(1)

            # Match struct: "struct NAME"
            if not identifier:
                struct_match = re.match(r'^struct\s+(\w+)', heading_text)
                if struct_match:
                    identifier = struct_match.group(1)

            # Match function definitions: "type funcName(params)" or "[type](#link) funcName(params)"
            # Need to handle markdown links in the return type
            if not identifier:
                func_match = re.search(r'(?:\[[^\]]+\]\([^)]+\)\s+)?\*?(\w+)\s*\(', heading_text)
                if func_match:
                    identifier = func_match.group(1)

            # Match plain identifiers (macros, simple definitions)
            if not identifier:
                plain_match = re.match(r'^([A-Z_][A-Z0-9_]*)\s*$', heading_text)
                if plain_match:
                    identifier = plain_match.group(1)

            # If we found an identifier and there are matching anchor IDs, add them
            if identifier and identifier in identifier_to_anchors:
                anchors = identifier_to_anchors[identifier]
                # Debug output for function pointers
                if 'Fn' in identifier:
                    print(f"    Adding {len(anchors)} anchor(s) for {identifier}")
                for anchor_id in anchors:
                    output_lines.append(f'<a id="{anchor_id}"></a>\n')
            elif identifier and 'Fn' in identifier:
                # Debug: identifier found but no anchors
                print(f"    WARNING: Found {identifier} but no anchors for it")

        output_lines.append(line)

    return '\n'.join(output_lines)


def fix_backticked_links(content):
    """
    Remove backticks around markdown links.

    sphinx-markdown-builder sometimes wraps links in backticks, which
    prevents them from being rendered as links. This function removes
    those backticks.

    Examples:
        `[text](#anchor)` -> [text](#anchor)
        `[text](url)` -> [text](url)
    """
    # Match backtick-wrapped links
    pattern = r'`(\[[^\]]+\]\([^)]+\))`'
    fixed = re.sub(pattern, r'\1', content)
    return fixed


def process_markdown_file(filepath):
    """Process a single markdown file to add anchors."""
    print(f"Processing {filepath}...")

    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()

    # Find all anchor IDs that are referenced
    anchor_map = find_definition_anchors(content)

    if not anchor_map:
        print(f"  No cross-references found, skipping.")
        return

    print(f"  Found {len(anchor_map)} cross-references to fix")

    # Debug: show a few examples
    fn_anchors = {k: v for k, v in anchor_map.items() if 'Fn' in v}
    if fn_anchors:
        print(f"  Example function pointers in anchor map:")
        for anchor_id, identifier in list(fn_anchors.items())[:5]:
            print(f"    {identifier} -> {anchor_id}")

    # Add anchors to definitions
    updated_content = add_anchors_to_definitions(content, anchor_map)

    # Fix backticked links
    updated_content = fix_backticked_links(updated_content)

    # Write back
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(updated_content)

    print(f"  Done!")


def main():
    if len(sys.argv) < 2:
        print("Usage: fix_markdown_anchors.py <markdown_dir>")
        sys.exit(1)

    markdown_dir = Path(sys.argv[1])

    if not markdown_dir.exists():
        print(f"Error: Directory {markdown_dir} does not exist")
        sys.exit(1)

    # Process all .md files in the directory
    md_files = list(markdown_dir.glob('*.md'))

    if not md_files:
        print(f"No markdown files found in {markdown_dir}")
        sys.exit(1)

    print(f"Found {len(md_files)} markdown file(s) to process\n")

    for md_file in md_files:
        process_markdown_file(md_file)

    print("\nAll files processed!")


if __name__ == '__main__':
    main()
